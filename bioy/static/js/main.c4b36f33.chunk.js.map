{"version":3,"sources":["utils.js","Header.js","data/store.js","authors/actions.js","authors/Authors.js","authors/reducer.js","authors/index.js","data/query.js","feed/actions.js","papers/actions.js","papers/Papers.js","papers/index.js","feed/Feed.js","feed/reducer.js","feed/index.js","feed/container.js","followees/Followees.js","followees/container.js","followees/index.js","readings/Readings.js","readings/container.js","readings/reducer.js","readings/index.js","search/actions.js","search/Search.js","search/container.js","search/reducer.js","search/index.js","tabs/Tabs.js","tabs/index.js","App.js","serviceWorker.js","index.js"],"names":["getLocalStorage","property","serializedState","localStorage","getItem","JSON","parse","err","console","log","setLocalStorage","value","stringify","setItem","hashString","str","hash","length","i","charCodeAt","setLocalCache","key","processAtomFeed","atomFeed","followedAuthors","readings","readingsGUID","map","paper","guid","papers","author","category","push","title","summary","authors","Array","isArray","a","name","isFollowed","includes","categories","c","toRead","rLog","reducerName","state","action","toUpperCase","type","Header","styled","header","px","py","color","Store","reducer","initState","instance","this","consumers","Object","assign","deepFreeze","o","freeze","getOwnPropertyNames","forEach","prop","hasOwnProperty","isFrozen","consumer","concat","act","dispatch","reducedSlices","entries","reduced","_dispatch","FOLLOW_AUTHOR","UNFOLLOW_AUTHOR","follow","unFollow","AuthorList","ul","Author","li","FollowAuthor","button","props","animate","UnFollowAuthor","Authors","isFetching","onClick","store","actions","components","filter","NAME","baseURL","arxiv_categories","getFeed","urlfeed","callback","req","request","feedparser","FeedParser","feedItems","on","response","statusCode","pipe","message","item","read","undefined","fetchAtomFeed","args","Promise","resolve","reject","authorQuery","names","split","join","getQueryByTerm","term","any_category","RECEIVE_FEED","REQUEST_FEED","requestFeed","arxivQuery","receiveFeed","fetchFeed","then","error","ADD_PAPER","add","PaperList","PaperEntry","div","PaperTitle","h3","PaperSummary","p","AddToReadList","Paper","Papers","items","className","PapersContainer","FeedTitle","FeedEmptyMsg","feed","getState","followees","lastUpdated","receivedAt","feed_","FeedContainer","subscribe","setState","prevProps","prevState","updateHeight","Feed","React","PureComponent","unFollowAuthor","FollowedAuthorsList","FollowedAuthor","FollowedAuthorsTitle","NoFolloweesMsg","FollowedAuthorsContainer","section","FolloweesContainer","_queryByFollowers","max_results","any_author","search_query","pagination","query","getQueryURL","cachedFeed","Followees","ReadingList","ReadingListEntry","ReadingListTitle","ReadingListEmptyMsg","ReadingListContainer","ReadingsContainer","Readings","some","RECEIVE_PAPERS","REQUEST_PAPERS","requestPapers","receivePapers","fetchPapers","SearchInput","_onChange","e","target","_handleKeyDown","htmlFor","onChange","onKeyDown","id","placeholder","Component","results","SearchContainer","searchResults","followeesChanged","readingsChanged","Search","searchResults_","Tab","label","isActive","handleClick","isDisabled","idx","variant","href","Tabs","labels","activeIdx","alignItems","tabIdx","stateSchema","Date","now","papersPerAuthor","search","tabs","rebass","variants","navActive","nav","colors","primary","App","index","handleChange","event","handleChangeIndex","swSty","slide","paddingLeft","space","paddingRight","minHeight","WebkitOverflowScrolling","theme","onChangeIndex","disableLazyLoading","enableMouseEvents","animateHeight","swipeableActions","style","overflowY","Boolean","window","location","hostname","match","ReactDOM","render","Fragment","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.c4b36f33.chunk.js","sourcesContent":["/*\n * Some utils for freezing objects, logging and working with the\n * localStorage.\n */\n\nexport const getLocalStorage = (property = \"state\") => {\n  try {\n    const serializedState = localStorage.getItem(property);\n    if (serializedState === null) {\n      return undefined;\n    }\n    return JSON.parse(serializedState);\n  } catch (err) {\n    console.log(\"localStorage.get complains: \", err);\n    return undefined;\n  }\n};\n\nexport const setLocalStorage = (property, value) => {\n  try {\n    const serializedState = JSON.stringify(value);\n    localStorage.setItem(property, serializedState);\n  } catch (err) {\n    console.log(\"localStorage.set complains: \", err);\n  }\n};\n\nfunction hashString(str) {\n  let hash = 0;\n  if (str.length === 0) return hash;\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i);\n    hash = (hash << 5) - hash + char;\n    hash = hash & hash; // Convert to 32bit integer\n  }\n  return hash;\n}\n\nexport const setLocalCache = (key, value) => {\n  setLocalStorage(hashString(key), value);\n};\n\nexport const getLocalCache = key => {\n  return getLocalStorage(hashString(key));\n};\n\n/**\n * Flattens an Atom feed of papers into a simpler data structure.\n * Eg.: paper[\"atom:author\"][*].name[\"#\"] -> paper.authors\n *\n * @param {Array} atomFeed (Atom feed)\n */\nexport const processAtomFeed = (atomFeed, followedAuthors, readings=[]) => {\n  const readingsGUID = readings.map(paper => paper.guid);\n  let papers = [];\n  for (const paper of atomFeed) {\n    const author = paper[\"atom:author\"];\n    const category = paper[\"atom:category\"];\n    papers.push({\n      title: paper.title,\n      summary: paper.summary,\n      guid: paper.guid,\n      authors: Array.isArray(author)\n        ? author.map(a => ({\n            name: a[\"name\"][\"#\"],\n            isFollowed: followedAuthors.includes(a[\"name\"][\"#\"])\n          }))\n        : [\n            {\n              name: author[\"name\"][\"#\"],\n              isFollowed: followedAuthors.includes(author[\"name\"][\"#\"])\n            }\n          ],\n      categories: Array.isArray(category)\n        ? category.map(c => c[\"@\"][\"term\"])\n        : [category[\"@\"][\"term\"]],\n      toRead: readingsGUID.includes(paper.guid)\n    });\n  }\n  return papers;\n};\n\n/**\n * Make an object immutable.\n * @param {Object} o\n */\nexport const deepFreeze = o => {\n  Object.freeze(o);\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      o.hasOwnProperty(prop) &&\n      o[prop] !== null &&\n      (typeof o[prop] === \"object\" || typeof o[prop] === \"function\") &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n};\n\nexport const rLog = (reducerName, state, action) => {\n  console.log(`${reducerName.toUpperCase()} REDUCER: `);\n  console.log(\"  type: \", action.type);\n  console.log(\"  state: \", state);\n  console.log(\"  action: \", action);\n};\n","import { Heading } from \"rebass/styled-components\";\nimport React from \"react\";\nimport styled from \"styled-components\";\n\nconst Header = styled.header`\n  background-color: #000;\n`;\n\nexport default () => {\n  return (\n    <Header>\n      <Heading px={3} py={2} color=\"white\">ReadFive.</Heading>\n    </Header>\n  );\n};\n","//@ts-check\nimport { deepFreeze } from \"../utils\";\n\nclass Store {\n  static instance;\n  constructor(reducer, initState) {\n    if (Store.instance) {\n      console.log(\"Warning, Store is a singleton!\");\n      return Store.instance;\n    }\n    this.reducer = reducer;\n    this.consumers = [];\n\n    if (initState) {\n      this.state = Object.assign({}, initState);\n    }\n\n    // kind of a singleton\n    this.instance = this;\n  }\n\n  /**\n   * Return an immutable copy of the current this.state.\n   *\n   * @returns Immutable Object.\n   * @memberof Store\n   */\n  getState() {\n    return deepFreeze(Object.assign({}, this.state));\n  }\n\n  subscribe(consumer) {\n    this.consumers = this.consumers.concat(consumer);\n  }\n\n  _dispatch() {\n    for (var consumer of this.consumers) {\n      consumer();\n    }\n  }\n\n  dispatch(action) {\n    if (typeof action === \"function\") {\n      // you can see this as redux-thunk\n      action(act => this.dispatch(act));\n    } else {\n      // {\"state.fieldA\": newValues, \"state.fieldB\": newValues, ...}\n      const reducedSlices = this.reducer(this.state, action);\n\n      // update the state based on the keys of reducedSlices, but only\n      // if there are any differences.\n      if (this.state) {\n        Object.entries(reducedSlices).forEach(([reducer, reduced]) => {\n          if (JSON.stringify(reduced) !== JSON.stringify(this.state[reducer])) {\n            Object.assign(this.state, { [reducer]: reduced });\n          }\n        });\n      } else {\n        this.state = {};\n        Object.entries(reducedSlices).forEach(([reducer, reduced]) => {\n          Object.assign(this.state, { [reducer]: reduced });\n        });\n      }\n    }\n\n    // Call all consumers? Hmm...\n    this._dispatch();\n  }\n}\n\nexport default Store;\n","export const FOLLOW_AUTHOR = \"FOLLOW_AUTHOR\";\nexport const UNFOLLOW_AUTHOR = \"UNFOLLOW_AUTHOR\";\n\nexport function follow(author) {\n  return { type: FOLLOW_AUTHOR, author };\n}\n\nexport function unFollow(author) {\n  return { type: UNFOLLOW_AUTHOR, author };\n}\n","import React from \"react\";\nimport styled from \"styled-components\";\n\nimport { store } from \"../App\";\nimport * as actions from \"./actions\";\n\nconst AuthorList = styled.ul`\n  font-size: 14px;\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nconst Author = styled.li`\n  display: inline-block;\n  margin-right: 20px;\n  margin-bottom: 3px;\n  // color: grey;\n`;\n\nconst FollowAuthor = styled.button`\n  margin-left: 5px;\n  font-weight: bold;\n  background-color: transparent;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 50%;\n  padding: 0 4px;\n  font-family: \"Lucida Console\", Monaco, monospace;\n  border-color: ${props => (props.animate ? \"green\" : \"#000\")};\n  color: ${props => (props.animate ? \"green\" : \"#000\")};\n`;\n\nconst UnFollowAuthor = styled.button`\n  margin-left: 5px;\n  font-weight: bold;\n  background-color: transparent;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 50%;\n  border-color: crimson;\n  color: crimson;\n  padding: 0 4px;\n  font-family: \"Lucida Console\", Monaco, monospace;\n  transform: rotate(45deg);\n`;\n\nexport const Authors = ({ authors, isFetching }) => {\n  return (\n    <AuthorList>\n      {authors.map(author => (\n        <Author key={author.name}>\n          {author.name}\n          {author.isFollowed ? (\n            <UnFollowAuthor\n              onClick={() => store.dispatch(actions.unFollow(author.name))}\n            >\n              {\"+\"}\n            </UnFollowAuthor>\n          ) : (\n            <FollowAuthor\n              onClick={() => store.dispatch(actions.follow(author.name))}\n              animate={isFetching}\n            >\n              {\"+\"}\n            </FollowAuthor>\n          )}\n        </Author>\n      ))}\n    </AuthorList>\n  );\n};\n","import * as actions from \"./actions\";\n\nimport { rLog } from \"../utils\";\n\n//\n\nfunction authors(state = [], action) {\n  rLog(\"authors\", state, action);\n  switch (action.type) {\n    case actions.FOLLOW_AUTHOR:\n      if (state.includes(action.author)) {\n        return state;\n      }\n      return state.concat(action.author);\n    case actions.UNFOLLOW_AUTHOR:\n      return state.filter(author => author !== action.author);\n    default:\n      return state;\n  }\n}\n\nexport default authors;\n","import * as components from \"./Authors\";\nimport * as actions from \"./actions\";\nimport reducer from \"./reducer\";\n\nconst NAME = \"authors\";\n\nexport default { actions, components, reducer, NAME };\n","import FeedParser from \"feedparser\";\nimport request from \"request\";\n\nconst baseURL = \"https://export.arxiv.org/api/query?\";\nconst arxiv_categories = [\"cs.AI\", \"cs.CV\", \"cs.LG\", \"cs.NE\", \"stat.ML\"];\n//\n\nfunction getFeed(urlfeed, callback) {\n  var req = request(urlfeed);\n  var feedparser = new FeedParser();\n  var feedItems = [];\n  req.on(\"response\", function(response) {\n    var stream = this;\n    if (response.statusCode === 200) {\n      stream.pipe(feedparser);\n    }\n  });\n  req.on(\"error\", function(err) {\n    console.log(\"getFeed: err.message == \" + err.message);\n  });\n  feedparser.on(\"readable\", function() {\n    try {\n      var item = this.read();\n      if (item !== null) {\n        //2/9/17 by DW\n        feedItems.push(item);\n      }\n    } catch (err) {\n      console.log(\"getFeed: err.message == \" + err.message);\n    }\n  });\n  feedparser.on(\"end\", function() {\n    callback(undefined, feedItems);\n  });\n  feedparser.on(\"error\", function(err) {\n    console.log(\"getFeed: err.message == \" + err.message);\n    callback(err);\n  });\n}\n\nconst fetchAtomFeed = (...args) => {\n  return new Promise((resolve, reject) => {\n    getFeed(...args, (err, atomFeed) => {\n      if (err) return reject(err);\n      return resolve(atomFeed);\n    });\n  });\n};\n\nfunction authorQuery(author) {\n  /**\n   * Receives an author's name and returns a slug necessary to properly\n   * query the arXiv API.\n   *\n   * Examples:\n   *  \"Jascha Sohl-Dickstein\" -> \"(au:Jascha+AND+au:Sohl_Dickstein)\"\n   *  \"Yee Whye Teh\" -> \"(au:Yee+AND+au:Whye+AND+au:Teh)\"\n   *\n   * @param {string} author (A string such as \"Jascha Sohl-Dickstein\")\n   * @returns {string}\n   */\n  const names = author.split(\" \").map(name => name.split(\"-\").join(\"_\"));\n  return `%28${names.map(name => `au:${name}`).join(\"+AND+\")}%29`;\n}\n\nfunction getQueryURL(authors, max_results) {\n  /**\n   * Receives a list of authors and builds a query using logic operators\n   * according to https://arxiv.org/help/api/user-manual#query_details\n   *\n   * Specifically it builds something like:\n   * (cs.AI OR cs.CV OR ...) AND (authorQuery OR authorQuery OR authorQuery ...)\n   *\n   * @param {Array} authors An array of author names for which we want to query\n   * for their latest papers.\n   * @returns\n   */\n\n  const any_category = `%28cat:${arxiv_categories.join(\"+OR+\")}%29`;\n  const any_author = `%28${authors.map(authorQuery).join(\"+OR+\")}%29`;\n  const search_query = `search_query=${any_category}+AND+${any_author}`;\n\n  const pagination = `&start=0&max_results=${max_results}`;\n  const sorting = \"&sortBy=submittedDate\";\n\n  // finaly build the actual query\n  const query = `${baseURL}${search_query}${pagination}${sorting}`;\n\n  console.log(`SEARCH QUERY: ${search_query}`);\n  console.log(`FULL QUERY  : ${query}`);\n  return query;\n}\n\nexport const getQueryByTerm = term => {\n  const any_category = `%28cat:${arxiv_categories.join(\"+OR+\")}%29`;\n  return (\n    `${baseURL}search_query=` +\n    `${any_category}+AND+` +\n    `%28all:${term}%29&start=0&max_results=15&sortBy=submittedDate`\n  );\n};\n\nexport { fetchAtomFeed, getQueryURL };\n","import { fetchAtomFeed } from \"../data/query\";\n//\n\nexport const RECEIVE_FEED = \"RECEIVE_FEED\";\nexport const REQUEST_FEED = \"REQUEST_FEED\";\n\n// sync action creators that will work with async action creators\n\nexport function requestFeed(arxivQuery) {\n  return {\n    type: REQUEST_FEED,\n    arxivQuery\n  };\n}\n\nexport function receiveFeed(arxivQuery, atomFeed) {\n  return {\n    type: RECEIVE_FEED,\n    arxivQuery,\n    atomFeed: atomFeed\n  };\n}\n\n// A thunk action creator, I guess?\n\nexport function fetchFeed(arxivQuery) {\n  return function(dispatch) {\n    // update app state with the request status\n    dispatch(requestFeed(arxivQuery));\n\n    return fetchAtomFeed(arxivQuery)\n      .then(\n        response => response,\n        error => console.log(\"Oh shit, \", error)\n      )\n      .then(response => dispatch(receiveFeed(arxivQuery, response)));\n  };\n}\n","export const ADD_PAPER = \"ADD_PAPER\";\n\n// action creators\n\nexport function add(paper) {\n  return { type: ADD_PAPER, paper };\n}\n","import * as actions from \"./actions\";\n\nimport Latex from \"react-latex\";\nimport React from \"react\";\nimport authors from \"../authors\";\nimport { store } from \"../App\";\nimport styled from \"styled-components\";\n\n//\n\nconst { Authors } = authors.components;\n\nconst PaperList = styled.ul`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nconst PaperEntry = styled.div`\n  margin-bottom: 20px;\n`;\n\nconst PaperTitle = styled.h3``;\n\nconst PaperSummary = styled.p`\n  overflow-wrap: break-word;\n`;\n\nconst AddToReadList = styled.button`\n  margin: 0 5px 0 0;\n  font-weight: bold;\n  background-color: transparent;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 25%;\n  padding: 0 4px;\n  font-family: \"Lucida Console\", Monaco, monospace;\n  border-color: #000;\n`;\n\nconst Paper = paper => {\n  return (\n    <PaperEntry>\n      <PaperTitle>\n        {(paper.toRead !== true) && (\n          <AddToReadList onClick={() => store.dispatch(actions.add(paper))}>\n            {\"+\"}\n          </AddToReadList>\n        )}\n        {paper.title}\n      </PaperTitle>\n      <Authors authors={paper.authors} isFetching={paper.isFetching} />\n      <PaperSummary>\n        <Latex>{paper.summary}</Latex>\n      </PaperSummary>\n    </PaperEntry>\n  );\n};\n\nexport default ({ papers }) => {\n  return (\n    <section>\n      <PaperList>\n        {papers.items.map(paper => (\n          <li key={paper.guid} className=\"Paper\">\n            <Paper\n              title={paper.title}\n              authors={paper.authors}\n              summary={paper.summary}\n              guid={paper.guid}\n              toRead={paper.toRead}\n              isFetching={papers.isFetching}\n            />\n          </li>\n        ))}\n      </PaperList>\n    </section>\n  );\n};\n","import Papers from \"./Papers\";\nimport PapersContainer from \"./container\";\nimport * as actions from \"./actions\";\nimport reducer from \"./reducer\";\n\nconst NAME = \"papers\";\nconst components = { Papers, PapersContainer };\n\nexport default { NAME, actions, reducer, components };\n","import React from \"react\";\nimport papers from \"../papers\";\nimport styled from \"styled-components\";\n\n//\n\nconst { Papers } = papers.components;\n\nconst FeedTitle = styled.h3``;\n\nconst FeedEmptyMsg = styled.p`\n  font-style: italic;\n`;\n\nexport default ({ feed }) => {\n  return (\n    <section>\n      <FeedTitle>\n        Papers by authors you follow:\n      </FeedTitle>\n      {feed.items.length === 0 && (\n        <FeedEmptyMsg>\n          Your feed is empty!\n          <br/><br/>Just one more swipe right to the search view :).\n        </FeedEmptyMsg>\n      )}\n      <Papers papers={feed} />\n    </section>\n  );\n};\n","import * as actions from \"./actions\";\n\nimport { processAtomFeed, rLog } from \"../utils\";\n\nimport { store } from \"../App\";\n\n//\n\n/*\n * Define some sync reducers that work with async action creators\n */\nfunction feed_(state = { isFetching: false, items: [] }, action) {\n  rLog(\"papers_\", state, action);\n  switch (action.type) {\n    case actions.REQUEST_FEED:\n      return Object.assign({}, state, {\n        arxivQuery: action.arxivQuery,\n        isFetching: true\n      });\n    case actions.RECEIVE_FEED:\n      // TODO: Can we do better than calling getState here?\n      const { followees, readings } = store.getState();\n\n      return Object.assign({}, state, {\n        isFetching: false,\n        arxivQuery: action.arxivQuery,\n        items: processAtomFeed(action.atomFeed, followees, readings),\n        atomFeed: action.atomFeed,\n        lastUpdated: action.receivedAt\n      });\n    default:\n      return state;\n  }\n}\n\nfunction feed(state = {}, action) {\n  rLog(\"papers\", state, action);\n  switch (action.type) {\n    case actions.REQUEST_FEED:\n    case actions.RECEIVE_FEED:\n      return Object.assign({}, state, feed_(state, action));\n    default:\n      return state;\n  }\n}\n\nexport default feed;\n","import * as actions from \"./actions\";\n\nimport FeedContainer from \"./container\";\nimport reducer from \"./reducer\";\n\nconst NAME = \"feed\";\nconst components = { FeedContainer };\n\nexport default { NAME, actions, reducer, components };\n","import Feed from \"./Feed\";\nimport React from \"react\";\nimport { store } from \"../App\";\n\n//\n\nclass FeedContainer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { isFetching: false, items: [], atomFeed: [] };\n    store.subscribe(() => this.setState(store.getState().feed));\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.props.updateHeight();\n  }\n\n  componentDidMount() {\n    this.setState(store.getState().feed);\n  }\n\n  render() {\n    return <Feed feed={this.state} />;\n  }\n}\n\nexport default FeedContainer;\n","import React from \"react\";\nimport authors from \"../authors\";\nimport { store } from \"../App\";\nimport styled from \"styled-components\";\n\n//\n\nconst unFollowAuthor = authors.actions.unFollow;\n\nconst FollowedAuthorsList = styled.ul`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nconst FollowedAuthor = styled.li`\n  margin: 5px 0;\n`;\nconst FollowedAuthorsTitle = styled.h3``;\n\nconst UnFollowAuthor = styled.button`\n  margin-left: 5px;\n  font-weight: bold;\n  background-color: transparent;\n  border-width: 2px;\n  border-style: solid;\n  border-radius: 50%;\n  border-color: crimson;\n  color: crimson;\n  padding: 0 4px;\n  font-family: \"Lucida Console\", Monaco, monospace;\n  transform: rotate(45deg);\n  float: right;\n`;\n\nconst NoFolloweesMsg = styled.p`\n  font-style: italic;\n`;\n\nconst FollowedAuthorsContainer = styled.section``;\n\nexport default ({ followees }) => {\n  return (\n    <FollowedAuthorsContainer>\n      <FollowedAuthorsTitle>{\"You are following: \"}</FollowedAuthorsTitle>\n      {followees.length === 0 && (\n        <NoFolloweesMsg>\n          You are not following anyone, swipe right to the search view and start\n          following researchers.\n        </NoFolloweesMsg>\n      )}\n      <FollowedAuthorsList>\n        {followees.map(author => (\n          <FollowedAuthor key={author}>\n            {author}\n            <UnFollowAuthor\n              onClick={() => store.dispatch(unFollowAuthor(author))}\n            >\n              {\"+\"}\n            </UnFollowAuthor>\n          </FollowedAuthor>\n        ))}\n      </FollowedAuthorsList>\n    </FollowedAuthorsContainer>\n  );\n};\n","import { getLocalCache, setLocalCache } from \"../utils\";\n\nimport Followees from \"./Followees\";\nimport React from \"react\";\nimport feed from \"../feed\";\nimport { getQueryURL } from \"../data/query\";\nimport { store } from \"../App\";\n\n//\n\nconst { fetchFeed, receiveFeed } = feed.actions;\n\nclass FolloweesContainer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { followees: [] };\n\n    // subscribers\n    store.subscribe(() =>\n      this.setState({ followees: store.getState().followees })\n    );\n    // localStorage subscriber\n    store.subscribe(() => {\n      const { arxivQuery, atomFeed } = store.getState().feed;\n      if (arxivQuery) {\n        setLocalCache(arxivQuery, atomFeed);\n      }\n    });\n  }\n\n  componentDidMount() {\n    this.setState({ followees: store.getState().followees });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.followees.length !== this.state.followees.length) {\n      this._queryByFollowers();\n    }\n  }\n\n  _queryByFollowers() {\n    const arxivQuery = getQueryURL(\n      this.state.followees,\n      this.state.followees.length * 5\n    );\n\n    const cachedFeed = getLocalCache(arxivQuery);\n    if (cachedFeed) {\n      console.log(\"-------------- CACHE HIT! ------------------\");\n      store.dispatch(receiveFeed(arxivQuery, cachedFeed));\n    } else {\n      console.log(\"-------------- API CALL! -------------------\");\n      store.dispatch(fetchFeed(arxivQuery));\n    }\n  }\n\n  render() {\n    return <Followees followees={this.state.followees} />;\n  }\n}\n\nexport default FolloweesContainer;\n","import Followees from \"./Followees\";\nimport FolloweesContainer from \"./container\";\nimport * as actions from \"./actions\";\nimport reducer from \"./reducer\";\n\nconst NAME = \"followees\";\nconst components = { Followees, FolloweesContainer };\n\nexport default { NAME, actions, reducer, components };\n","import React from \"react\";\nimport styled from \"styled-components\";\n//\n\nconst ReadingList = styled.ul`\n  padding: 0;\n  margin: 0;\n  list-style: none;\n`;\n\nconst ReadingListEntry = styled.li`\n  margin: 1px 0;\n  padding: 5px 0 5px 5px;\n  // background: gainsboro;\n  border-bottom: 1px solid gainsboro;\n`;\n\nconst ReadingListTitle = styled.h3``;\n\nconst ReadingListEmptyMsg = styled.p`\n  font-style: italic;\n`;\n\nconst ReadingListContainer = styled.section``;\n\nexport default ({ readings }) => {\n  return (\n    <ReadingListContainer>\n      <ReadingListTitle>{\"Reading list: \"}</ReadingListTitle>\n      {readings.length === 0 && (\n        <ReadingListEmptyMsg>\n          Your reading list is empty.\n          <br />\n          <br />\n          Swipe right till you reach the search view or tap \"Search\". Search for\n          an author or a paper title and start adding papers to your reading\n          list and following researchers.\n        </ReadingListEmptyMsg>\n      )}\n      <ReadingList>\n        {readings.map(paper => (\n          <ReadingListEntry key={paper.guid}>{paper.title}</ReadingListEntry>\n        ))}\n      </ReadingList>\n    </ReadingListContainer>\n  );\n};\n","import React from \"react\";\nimport Readings from \"./Readings\";\nimport { store } from \"../App\";\n\nclass ReadingsContainer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = { readings: [] };\n    store.subscribe(() =>\n      this.setState({ readings: store.getState().readings })\n    );\n  }\n\n  componentDidMount() {\n    this.setState({ readings: store.getState().readings });\n  }\n\n  render() {\n    return <Readings readings={this.state.readings} />;\n  }\n}\n\nexport default ReadingsContainer;\n","import { rLog } from \"../utils\";\nimport papers from \"../papers\";\n// import actions from \"./actions\";\n//\n\nconst ADD_PAPER = papers.actions.ADD_PAPER;\n\nfunction readings(state = [], action) {\n  rLog(\"readings\", state, action);\n  switch (action.type) {\n    case ADD_PAPER:\n      // TODO: check if paper already exists!\n      if (state.some(paper => paper.guid === action.paper.guid)) {\n        return state;\n      }\n      return state.concat(action.paper);\n    default:\n      return state;\n  }\n}\n\nexport default readings;\n","import Readings from \"./Readings\";\nimport ReadingsContainer from \"./container\";\nimport * as actions from \"./actions\";\nimport reducer from \"./reducer\";\n\nconst NAME = \"readings\";\nconst components = { Readings, ReadingsContainer };\n\nexport default { NAME, actions, reducer, components };\n","import { fetchAtomFeed } from \"../data/query\";\n//\n\nexport const RECEIVE_PAPERS = \"RECEIVE_PAPERS\";\nexport const REQUEST_PAPERS = \"REQUEST_PAPERS\";\n\n// sync action creators that will work with async action creators\n\nexport function requestPapers(arxivQuery) {\n  return {\n    type: REQUEST_PAPERS,\n    arxivQuery\n  };\n}\n\nexport function receivePapers(arxivQuery, atomFeed) {\n  return {\n    type: RECEIVE_PAPERS,\n    arxivQuery,\n    atomFeed: atomFeed\n  };\n}\n\n// A thunk action creator, I guess?\n\nexport function fetchPapers(arxivQuery) {\n  return function(dispatch) {\n    // update app state with the request status\n    dispatch(requestPapers(arxivQuery));\n\n    return fetchAtomFeed(arxivQuery)\n      .then(\n        response => response,\n        error => console.log(\"Oh shit, \", error)\n      )\n      .then(response => dispatch(receivePapers(arxivQuery, response)));\n  };\n}\n","import { Input, Label } from \"@rebass/forms\";\n\nimport React from \"react\";\nimport { fetchPapers } from \"./actions\";\nimport {getQueryByTerm} from \"../data/query\"\nimport papers from \"../papers\";\nimport { store } from \"../App\";\n\n//\n\nconst Papers = papers.components.Papers;\n\nclass SearchInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { value: \"Pascanu\" };\n  }\n\n  _onChange = e => {\n    this.setState({ value: e.target.value });\n  };\n\n  _handleKeyDown = e => {\n    if (e.key === \"Enter\") {\n      console.log(\"Enter was pressed: \", e.target.value);\n      const query = getQueryByTerm(e.target.value);\n      store.dispatch(fetchPapers(query));\n    }\n  };\n\n  render() {\n    return (\n      <div>\n        <Label htmlFor=\"searchPaper\">\n          Search paper by author or title:\n          <br />\n          <br />\n        </Label>\n        <Input\n          onChange={this._onChange}\n          onKeyDown={this._handleKeyDown}\n          id=\"searchPaper\"\n          name=\"searchPaper\"\n          type=\"search\"\n          value={this.state.value}\n          placeholder={this.state.value}\n        />\n      </div>\n    );\n  }\n}\n\nexport default ({ results }) => {\n  return (\n    <section>\n      <SearchInput />\n      <Papers papers={results} />\n    </section>\n  );\n};\n","import React from \"react\";\nimport Search from \"./Search\";\nimport { receivePapers } from \"./actions\";\nimport { store } from \"../App.js\";\n//\n\nclass SearchContainer extends React.PureComponent {\n  constructor(props) {\n    super(props);\n    this.state = {\n      searchResults: { isFetching: false, items: [], atomFeed: [] },\n      followees: [],\n      readings: []\n    };\n    store.subscribe(() => {\n      const { searchResults, followees, readings } = store.getState();\n      this.setState({ searchResults, followees, readings });\n    });\n  }\n\n  componentDidMount() {\n    const { searchResults, followees, readings } = store.getState();\n    this.setState({\n      searchResults,\n      followees,\n      readings\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    this.props.updateHeight();\n\n    // we are trying to save another query\n    // use the previous atomFeed to do another receivePapers action\n    // in which we process it and check for followers\n    const { followees, readings } = this.state;\n    const followeesChanged = prevState.followees.length !== followees.length;\n    const readingsChanged = prevState.readings.length !== readings.length;\n    if (followeesChanged || readingsChanged) {\n      store.dispatch(\n        receivePapers(\n          this.state.searchResults.arxivQuery,\n          this.state.searchResults.atomFeed\n        )\n      );\n    }\n  }\n\n  render() {\n    return <Search results={this.state.searchResults} />;\n  }\n}\n\nexport default SearchContainer;\n","import * as actions from \"./actions\";\n\nimport { processAtomFeed, rLog } from \"../utils\";\n\nimport { store } from \"../App\";\n\n/*\n * Define some sync reducers that work with async action creators\n * TODO: there is a lot of duplication with the `feed` component.\n */\nfunction searchResults_(state = { isFetching: false, items: [] }, action) {\n  rLog(\"papers_\", state, action);\n  switch (action.type) {\n    case actions.REQUEST_PAPERS:\n      return Object.assign({}, state, {\n        arxivQuery: action.arxivQuery,\n        isFetching: true\n      });\n    case actions.RECEIVE_PAPERS:\n      // TODO: Can we do better than calling getState here?\n      const { followees, readings } = store.getState();\n\n      return Object.assign({}, state, {\n        isFetching: false,\n        arxivQuery: action.arxivQuery,\n        items: processAtomFeed(action.atomFeed, followees, readings),\n        atomFeed: action.atomFeed,\n        lastUpdated: action.receivedAt\n      });\n    default:\n      return state;\n  }\n}\n\nfunction searchResults(state = {}, action) {\n  rLog(\"papers\", state, action);\n  switch (action.type) {\n    case actions.REQUEST_PAPERS:\n    case actions.RECEIVE_PAPERS:\n      return Object.assign({}, state, searchResults_(state, action));\n    default:\n      return state;\n  }\n}\n\nexport default searchResults;\n","import * as actions from \"./actions\";\n\nimport Search from \"./Search\";\nimport SearchContainer from \"./container\";\nimport reducer from \"./reducer\";\n\nconst components = { Search, SearchContainer };\nconst NAME = \"search\";\n\nexport default { NAME, actions, reducer, components };\n","import { Flex, Link } from \"rebass/styled-components\";\n\nimport React from \"react\";\n\n//\n\nconst Tab = ({ label, isActive, isDisabled, handleClick, idx }) => {\n  return (\n    <Link\n      variant={isActive ? \"navActive\" : \"nav\"}\n      href=\"#!\"\n      onClick={e => handleClick(e, idx)}\n    >\n      {label}\n    </Link>\n  );\n};\n\nclass Tabs extends React.Component {\n  render() {\n    // TODO: should accept either some children of type Tab, either a list\n    // of their labels.\n    const { handleClick, labels, activeIdx } = this.props;\n\n    return (\n      <Flex alignItems=\"center\" py={2} px={2}>\n        {labels &&\n          labels.map((label, tabIdx) => (\n            <Tab\n              key={tabIdx}\n              label={label}\n              idx={tabIdx}\n              isActive={activeIdx === tabIdx}\n              handleClick={handleClick}\n            />\n          ))}\n      </Flex>\n    );\n  }\n}\n\nexport default Tabs;\n","import Tabs from \"./Tabs\";\n\nconst NAME = \"tabs\";\nexport default { NAME, Tabs };\n","//@ts-check\nimport \"./App.css\";\n\nimport { getLocalStorage, rLog, setLocalStorage } from \"./utils\";\n\nimport Header from \"./Header\";\nimport React from \"react\";\nimport Store from \"./data/store\";\nimport SwipeableViews from \"react-swipeable-views\";\nimport { ThemeProvider } from \"styled-components\";\nimport authors from \"./authors\";\nimport feed from \"./feed\";\nimport followees from \"./followees\";\nimport readings from \"./readings\";\nimport rebass from \"@rebass/preset\";\nimport search from \"./search\";\nimport tabs from \"./tabs\";\n\n//\n\nconst stateSchema = {\n  readings: [],\n  followees: [],\n  feed: {\n    isFetching: false,\n    items: [],\n    atomFeed: [],\n    lastUpdated: Date.now(),\n    arxivQuery: null\n  },\n  searchResults: {\n    isFetching: false,\n    items: [],\n    atomFeed: [],\n    arxivQuery: null\n  },\n  papersPerAuthor: 5\n};\n\nconst initState = Object.assign({}, stateSchema, getLocalStorage(\"state\"));\n\n/*\n * Define the root reducer\n */\n\nfunction readFiveApp(state = initState, action) {\n  rLog(\"ROOT\", state, action);\n  return {\n    followees: authors.reducer(state.followees, action), // using this for now\n    readings: readings.reducer(state.readings, action),\n    feed: feed.reducer(state.feed, action),\n    searchResults: search.reducer(state.searchResults, action)\n  };\n}\n\n/*\n * Configure the store\n */\nconst store = new Store(readFiveApp, initState);\n// Subscribe a logger\nstore.subscribe(() => console.log(\"DISPATCHED: \", store.getState()));\n// Subscribe the localStorage (to a limitted number of properties)\nstore.subscribe(() => {\n  const { readings, followees } = store.getState();\n  setLocalStorage(\"state\", { readings, followees });\n});\n\n/*\n * Continue with the React application.\n */\n\nconst { ReadingsContainer } = readings.components;\nconst { FolloweesContainer } = followees.components;\nconst { FeedContainer } = feed.components;\nconst { SearchContainer } = search.components;\nconst { Tabs } = tabs;\n\n// Monkey Patch the style\nrebass.variants.navActive = Object.assign({}, rebass.variants.nav, {\n  color: rebass.colors.primary\n});\nconsole.log(rebass);\n\nclass App extends React.Component {\n  state = { index: initState.readings.length === 0 ? 3 : 0 };\n\n  handleChange = (event, value) => {\n    this.setState({\n      index: value\n    });\n  };\n\n  handleChangeIndex = index => {\n    this.setState({\n      index: index\n    });\n  };\n\n  render() {\n    // index of the swipeable\n    const { index } = this.state;\n    console.log(\"Index: \", index)\n\n    // styles for the SwipeableViews\n    const swSty = {\n      slide: {\n        paddingLeft: rebass.space[3],\n        paddingRight: rebass.space[3],\n        minHeight: \"calc(100vh - 80px)\",\n        WebkitOverflowScrolling: \"touch\"\n      }\n    };\n\n    return (\n      <ThemeProvider theme={rebass}>\n        <Header />\n\n        <Tabs\n          labels={[\"To read\", \"Following\", \"Feed\", \"Search\"]}\n          handleClick={this.handleChange}\n          activeIdx={index}\n        />\n\n        <SwipeableViews\n          index={index}\n          onChangeIndex={this.handleChangeIndex}\n          disableLazyLoading={true}\n          enableMouseEvents={true}\n          animateHeight={true}\n          action={actions => {\n            console.log(\"Updating height...\")\n            this.swipeableActions = actions;\n          }}\n          style={{ overflowY: \"hidden\" }}\n        >\n          <div style={swSty.slide}>\n            <ReadingsContainer />\n          </div>\n          <div style={swSty.slide}>\n            <FolloweesContainer />\n          </div>\n          <div style={swSty.slide}>\n            <FeedContainer\n              updateHeight={() => this.swipeableActions.updateHeight()}\n            />\n          </div>\n          <div style={swSty.slide}>\n            <SearchContainer\n              updateHeight={() => this.swipeableActions.updateHeight()}\n            />\n          </div>\n        </SwipeableViews>\n      </ThemeProvider>\n    );\n  }\n}\n\nexport { App as default, store };\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport {Normalize} from 'styled-normalize'\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nconst Root = () => (\n  <React.Fragment>\n    <Normalize />\n    <App />\n  </React.Fragment>\n);\n\nReactDOM.render(<Root />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}